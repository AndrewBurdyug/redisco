{"google":"","name":"Redisco","body":"=======\r\nRedisco\r\n=======\r\nPython Containers and Simple Models for Redis\r\n\r\nDescription\r\n-----------\r\nRedisco allows you to store objects in Redis_. It is inspired by the Ruby library\r\nOhm_ and its design and code are loosely based on Ohm and the Django ORM.\r\nIt is built on top of redis-py_. It includes container classes that allow\r\neasier access to Redis sets, lists, and sorted sets.\r\n\r\nInstallation\r\n------------\r\nRedisco requires redis-py 2.0.0 so get it first.\r\n\r\n    pip install redis\r\n\r\nThen install redisco.\r\n\r\n    pip install redisco\r\n\r\n\r\nModels\r\n------\r\n\r\n::\r\n\r\n    from redisco import models\r\n    class Person(models.Model):\r\n        name = models.Attribute(required=True)\r\n        created_at = models.DateTimeField(auto_now_add=True)\r\n        fave_colors = models.ListField(str)\r\n\r\n    >>> person = Person(name=\"Conchita\")\r\n    >>> person.is_valid()\r\n    True\r\n    >>> person.save()\r\n    True\r\n    >>> conchita = Person.objects.filter(name='Conchita')[0]\r\n    >>> conchita.name\r\n    'Conchita'\r\n    >>> conchita.created_at\r\n    datetime.datetime(2010, 5, 24, 16, 0, 31, 954704)\r\n\r\n\r\nModel Attributes\r\n----------------\r\n\r\nAttribute\r\n    Stores unicode strings. If used for large bodies of text,\r\n    turn indexing of this field off by setting indexed=True.\r\n\r\nIntegerField\r\n    Stores an int. Ints are stringified using unicode() before saving to\r\n    Redis.\r\n\r\nCounter\r\n    An IntegerField that can only be accessed via Model.incr and Model.decr.\r\n\r\nDateTimeField\r\n    Can store a DateTime object. Saved in the Redis store as a float.\r\n\r\nDateField\r\n    Can store a Date object. Saved in Redis as a float.\r\n\r\nFloatField\r\n    Can store floats.\r\n\r\nBooleanField\r\n    Can store bools. Saved in Redis as 1's and 0's.\r\n\r\nReferenceField\r\n    Can reference other redisco model.\r\n\r\nListField\r\n    Can store a list of unicode, int, float, as well as other redisco models.\r\n\r\n\r\nAttribute Options\r\n-----------------\r\n\r\nrequired\r\n    If True, the attirbute cannot be None or empty. Strings are stripped to\r\n    check if they are empty. Default is False.\r\n\r\ndefault\r\n    Sets the default value of the attribute. Default is None.\r\n\r\nindexed\r\n    If True, redisco will create index entries for the attribute. Indexes\r\n    are used in filtering and ordering results of queries. For large bodies\r\n    of strings, this should be set to False. Default is True.\r\n\r\nvalidator\r\n    Set this to a callable that accepts two arguments -- the field name and\r\n    the value of the attribute. The callable should return a list of tuples\r\n    with the first item is the field name, and the second item is the error.\r\n\r\nunique\r\n    The field must be unique. Default is False.\r\n\r\nDateField and DateTimeField Options\r\n\r\nauto_now_add\r\n    Automatically set the datetime/date field to now/today when the object\r\n    is first created. Default is False.\r\n\r\nauto_now\r\n    Automatically set the datetime/date field to now/today everytime the object\r\n    is saved. Default is False.\r\n\r\n\r\nSaving and Validating\r\n---------------------\r\n\r\nTo save an object, call its save method. This returns True on success (i.e. when\r\nthe object is valid) and False otherwise.\r\n\r\nCalling Model.is_valid will validate the attributes and lists. Model.is_valid\r\nis called when the instance is being saved. When there are invalid fields,\r\nModel.errors will hold the list of tuples containing the invalid fields and\r\nthe reason for its invalidity. E.g.\r\n[('name', 'required'),('name', 'too short')]\r\n\r\nFields can be validated using the validator argument of the attribute. Just\r\npass a callable that accepts two arguments -- the field name and the value\r\nof the attribute. The callable should return a list of errors.\r\n\r\nModel.validate will also be called before saving the instance. Override it\r\nto validate instances not related to attributes.\r\n\r\n::\r\n\r\n    def not_me(field_name, value):\r\n        if value == 'Me':\r\n            return ((field_name, 'it is me'),)\r\n\r\n    class Person(models.Model):\r\n        name = models.Attribute(required=True, validator=not_me)\r\n        age = models.IntegerField()\r\n\r\n        def validate(self):\r\n            if self.age and self.age < 21:\r\n                self._errors.append(('age', 'below 21'))\r\n\r\n    >>> person = Person(name='Me')\r\n    >>> person.is_valid()\r\n    False\r\n    >>> person.errors\r\n    [('name', 'it is me')]\r\n\r\n\r\nQueries\r\n-------\r\n\r\nQueries are executed using a manager, accessed via the objects class\r\nattribute.\r\n\r\n::\r\n\r\n    Person.objects.all()\r\n    Person.objects.filter(name='Conchita')\r\n    Person.objects.filter(name='Conchita').first()\r\n    Person.objects.all().order('name')\r\n    Person.objects.filter(fave_colors='Red')\r\n\r\nRanged Queries\r\n--------------\r\n\r\nRedisco has a limited support for queries involving ranges -- it can only\r\nfilter fields that are numeric, i.e. DateField, DateTimeField, IntegerField,\r\nand FloatField. The zfilter method of the manager is used for these queries.\r\n\r\n::\r\n\r\n    Person.objects.zfilter(created_at__lt=datetime(2010, 4, 20, 5, 2, 0))\r\n    Person.objects.zfilter(created_at__gte=datetime(2010, 4, 20, 5, 2, 0))\r\n    Person.objects.zfilter(created_at__in=(datetime(2010, 4, 20, 5, 2, 0), datetime(2010, 5, 1)))\r\n\r\n\r\nContainers\r\n----------\r\nRedisco has three containers that roughly match Redis's supported data\r\nstructures: lists, sets, sorted set. Anything done to the container is\r\npersisted to Redis.\r\n\r\nSets\r\n    >>> from redisco.containers import Set\r\n    >>> s = Set('myset')\r\n    >>> s.add('apple')\r\n    >>> s.add('orange')\r\n    >>> s.members\r\n    set(['orange', 'apple'])\r\n    >>> t = Set('nset')\r\n    >>> t.add('kiwi')\r\n    >>> t.add('guava')\r\n    >>> t.members\r\n    set(['kiwi', 'guava'])\r\n    >>> s.update(t)\r\n    >>> s.members\r\n    set(['kiwi', 'orange', 'guava', 'apple'])\r\n\r\nLists\r\n    >>> import redis\r\n    >>> from redisco.containers import List\r\n    >>> l = List('alpha')\r\n    >>> l.append('a')\r\n    >>> l.append('b')\r\n    >>> l.append('c')\r\n    >>> 'a' in l\r\n    True\r\n    >>> 'd' in l\r\n    False\r\n    >>> len(l)\r\n    3\r\n    >>> l.index('b')\r\n    1\r\n    >>> l.members\r\n    ['a', 'b', 'c']\r\n\r\n\r\nSorted Sets\r\n    >>> zset = SortedSet('zset')\r\n    >>> zset.members\r\n    ['d', 'a', 'b', 'c']\r\n    >>> 'e' in zset\r\n    False\r\n    >>> 'a' in zset\r\n    True\r\n    >>> zset.rank('d')\r\n    0\r\n    >>> zset.rank('b')\r\n    2\r\n    >>> zset[1]\r\n    'a'\r\n    >>> zset.add('f', 200)\r\n    >>> zset.members\r\n    ['d', 'a', 'b', 'c', 'f']\r\n    >>> zset.add('d', 99)\r\n    >>> zset.members\r\n    ['a', 'b', 'c', 'd', 'f']\r\n\r\n\r\nDicts/Hashes\r\n    >>> h = cont.Hash('hkey')\r\n    >>> len(h)\r\n    0\r\n    >>> h['name'] = \"Richard Cypher\"\r\n    >>> h['real_name'] = \"Richard Rahl\"\r\n    >>> h\r\n    <Hash 'hkey' {'name': 'Richard Cypher', 'real_name': 'Richard Rahl'}>\r\n    >>> h.dict\r\n    {'name': 'Richard Cypher', 'real_name': 'Richard Rahl'}\r\n\r\n\r\nAdditional Info on Containers\r\n-----------------------------\r\n\r\nSome methods of the Redis client that require the key as the first argument\r\ncan be accessed from the container itself.\r\n\r\n    >>> l = List('mylist')\r\n    >>> l.lrange(0, -1)\r\n    0\r\n    >>> l.rpush('b')\r\n    >>> l.rpush('c')\r\n    >>> l.lpush('a')\r\n    >>> l.lrange(0, -1)\r\n    ['a', 'b', 'c']\r\n    >>> h = Hash('hkey')\r\n    >>> h.hset('name', 'Richard Rahl')\r\n    >>> h\r\n    <Hash 'hkey' {'name': 'Richard Rahl'}>\r\n\r\n\r\nConnecting to Redis\r\n-------------------\r\n\r\nAll models and containers use a global Redis client object to\r\ninteract with the key-value storage. By default, it connects\r\nto localhost:6379, selecting db 0. If you wish to specify settings:\r\n\r\n::\r\n\r\n    import redisco\r\n    redisco.connection_setup(host='localhost', port=6380, db=10)\r\n\r\nThe arguments to connect are simply passed to the redis.Redis init method.\r\n\r\nFor the containers, you can specify a second argument as the Redis client.\r\nThat client object will be used instead of the default.\r\n\r\n    >>> import redis\r\n    >>> r = redis.Redis(host='localhost', port=6381)\r\n    >>> Set('someset', r)\r\n\r\n\r\nCredits\r\n-------\r\n\r\nMost of the concepts are taken from `Soveran`_'s Redis related Ruby libraries.\r\ncyx_ for sharing his expertise in indexing in Redis.\r\nDjango, of course, for the popular model API.\r\n\r\n.. _Redis: http://code.google.com/p/redis/\r\n.. _Ohm: http://github.com/soveran/ohm/\r\n.. _redis-py: http://github.com/andymccurdy/redis-py/\r\n.. _`Soveran`: http://github.com/soveran\r\n.. _cyx: http://github.com/cyx\r\n","tagline":"A Python Library for Simple Models and Containers Persisted in Redis ","note":"Don't delete this file! It's used internally to help with page regeneration."}